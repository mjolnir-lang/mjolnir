/// Utility classes, functions, and macros.


/// `WlObject`
///
/// A protocol object.
///
/// A `WlObject` is an opaque struct identifying the protocol object
/// underlying a `WlProxy` or `WlResource`.
///
/// NOTE: Functions accessing a `WlObject` are not normally used by client code.
/// Clients should normally use the higher level interface generated by the
/// scanner to interact with compositor objects.
class WlObject {

}


/// Protocol message signature
///
/// A `WlMessage` describes the signature of an actual protocol message, such as a
/// request or event, that adheres to the Wayland protocol wire format. The
/// protocol implementation uses a wl_message within its demarshal machinery for
/// decoding messages between a compositor and its clients. In a sense, a
/// wl_message is to a protocol message like a class is to an object.
///
/// The `name` of a `WlMessage` is the name of the corresponding protocol message.
///
/// The `signature` is an ordered list of symbols representing the data types
/// of message arguments and, optionally, a protocol version and indicators for
/// nullability. A leading integer in the `signature` indicates the _since_
/// version of the protocol message. A `?` preceding a data type symbol indicates
/// that the following argument type is nullable. While it is a protocol violation
/// to send messages with non-nullable arguments set to `null`, event handlers in
/// clients might still get called with non-nullable object arguments set to
/// `null`. This can happen when the client destroyed the object being used as
/// argument on its side and an event referencing that object was sent before the
/// server knew about its destruction. As this race cannot be prevented, clients
/// should - as a general rule - program their event handlers such that they can
/// handle object arguments declared non-nullable being `null` gracefully.
///
/// When no arguments accompany a message, `signature` is an empty string.
///
/// Symbols:
///
/// - `i`: `i32`
/// - `u`: `uint`
/// - `f`: `fixed`
/// - `s`: `string`
/// - `o`: `object`
/// - `n`: `new_id`
/// - `a`: `array`
/// - `h`: `fd`
/// - `?`: following argument (`o` or `s`) is nullable
///
/// While demarshaling primitive arguments is straightforward, when demarshaling
/// messages containing `object` or `new_id` arguments, the protocol
/// implementation often must determine the type of the object. The `types` of a
/// wl_message is an array of `WlInterface` references that correspond to `o` and
/// `n` arguments in `signature`, with `null` placeholders for arguments with
/// non-object types.
///
/// Consider the protocol event `WlDisplay` `delete_id` that has a single `uint`
/// argument. The `WlMessage` is:
///
/// ```
/// { "delete_id", "u", [null] }
/// ```
///
/// Here, the message `name` is `"delete_id"`, the `signature` is `"u"`, and the
/// argument `types` is `[null]`, indicating that the `uint` argument has no
/// corresponding WlInterface since it is a primitive argument.
///
/// In contrast, consider a `wl_foo` interface supporting protocol request `bar`
/// that has existed since version 2, and has two arguments: a `uint` and an
/// object of type `wl_baz_interface` that may be `null`. Such a `wl_message`
/// might be:
///
/// ```
/// { "bar", "2u?o", [null, &wl_baz_interface] }
/// ```
///
/// Here, the message `name` is `"bar"`, and the `signature` is `"2u?o"`. Notice
/// how the `2` indicates the protocol version, the `u` indicates the first
/// argument type is `uint`, and the `?o` indicates that the second argument
/// is an object that may be `null`. Lastly, the argument `types` array indicates
/// that no WlInterface corresponds to the first argument, while the type
/// `wl_baz_interface` corresponds to the second argument.
///
/// `WlArgument`
/// `WlInterface`
/// \sa <a href="https://wayland.freedesktop.org/docs/html/ch04.html#sect-Protocol-Wire-Format">Wire Format</a>
////
struct wl_message {

    // Message name
    StringView name;

    // Message signature
    StringView signature;

    // Object argument interfaces
    const WlInterface **types;
};


/// Protocol object interface
///
/// A `WlInterface` describes the API of a protocol object defined in the Wayland
/// protocol specification. The protocol implementation uses a `WlInterface`
/// within its marshalling machinery for encoding client requests.
///
/// The `name` of a `WlInterface` is the name of the corresponding protocol
/// interface, and `version` represents the version of the interface. The members
/// `method_count` and `event_count` represent the number of `methods` (requests)
/// and `events` in the respective `WlMessage` members.
///
/// For example, consider a protocol interface `foo`, marked as version `1`, with
/// two requests and one event.
///
/// ```xml
/// <interface name="foo" version="1">
///   <request name="a"></request>
///   <request name="b"></request>
///   <event name="c"></event>
/// </interface>
/// ```
///
/// Given two wl_message arrays `foo_requests` and `foo_events`, a WlInterface
/// for `foo` might be:
///
/// ```
/// WlInterface foo_interface = WlInterface(
///     "foo", 1,
///     2, foo_requests,
///     1, foo_events
/// );
/// };
/// ```
///
/// NOTE: The server side of the protocol may define interface <em>implementation
///       types</em> that incorporate the term `interface` in their name. Take
///       care to not confuse these server-side `struct`s with a WlInterface
///       variable whose name also ends in `interface`. For example, while the
///       server may define a type `struct wl_foo_interface`, the client may
///       define a `struct WlInterface wl_foo_interface`.
///
/// \sa wl_message
/// \sa wl_proxy
/// \sa <a href="https://wayland.freedesktop.org/docs/html/ch04.html#sect-Protocol-Interfaces">Interfaces</a>
/// \sa <a href="https://wayland.freedesktop.org/docs/html/ch04.html#sect-Protocol-Versioning">Versioning</a>
class WlInterface {

    // Interface name
    StringView name;

    // Interface version
    i32 version;

    // Number of methods (requests)
    i32 method_count;

    // Method (request) signatures
    const struct wl_message *methods;

    // Number of events
    i32 event_count;

    // Event signatures
    const WlMessage *events;


    bool is_equal(const WlInterface &other) {
        // In most cases the pointer equality test is sufficient.
        // However, in some cases, depending on how things are split
        // across shared objects, we can end up with multiple
        // instances of the interface metadata constants.  So if the
        // pointers match, the interfaces are equal, if they don't
        // match we have to compare the interface names.
        return &this == &other || name == other.name;
    }
}


/// `WlList`
///
/// Doubly-linked list
///
/// On its own, an instance of `WlList` represents the sentinel head of
/// a doubly-linked list, and must be initialized using `WlList::init()`.
/// When empty, the list head's `next` and `prev` members point to the list head
/// itself, otherwise `next` references the first element in the list, and `prev`
/// refers to the last element in the list.
///
/// Use the `WlList` type to represent both the list head and the links
/// between elements within the list. Use `WlList::is_empty()` to determine if the
/// list is empty in O(1).
///
/// All elements in the list must be of the same type. The element type must have
/// a `WlList` member, often named `link` by convention. Prior to
/// insertion, there is no need to initialize an element's `link` - invoking
/// `WlList.init()` on an individual list element's `WlList` member is
/// unnecessary if the very next operation is `WlList::insert()`. However, a
/// common idiom is to initialize an element's `link` prior to removal - ensure
/// safety by invoking `WlList::init()` before `WlList::remove()`.
///
/// Consider a list reference `WlList foo_list`, an element type as
/// `Element`, and an element's link member as `WlList link`.
///
/// The following code initializes a list and adds three elements to it.
///
/// ```
/// struct Element {
///     i32 foo;
///     WlList link;
/// }
/// Element e1, e2, e3;
///
/// WlList foo_list = WlList();
/// foo_list.insert(&e1.link); // e1 is the first element
/// foo_list.insert(&e2.link); // e2 is now the first element
/// e2.link.insert(&e3.link);  // insert e3 after e2
/// ```
///
/// The list now looks like `[e2, e3, e1]`.
///
/// The `WlList` API provides some iterator macros. For example, to iterate
/// a list in ascending order:
///
/// ```
/// Element &e;
/// foo_list.for_each(e, link) {
///     do_something_with_element(e);
/// }
/// ```
///
/// See the documentation of each iterator for details.
/// http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/linux/list.h
class WlList {

    // Previous list element
    WlList *prev;

    // Next list element
    WlList *next;


    /// Initializes the list.
    ///
    /// `list` List to initialize
    WlList() {
        prev = this;
        next = this;
    }


    /// Inserts an element into the list, after the element represented by `list`.
    /// When `list` is a reference to the list itself (the head), set the containing
    /// struct of `elm` as the first element in the list.
    ///
    /// NOTE: If `elm` is already part of a list, inserting it again will lead to
    ///       list corruption.
    ///
    /// `elm` Link of the containing struct to insert into the list
    void insert(WlList &elm) {
        elm.prev = list;
        elm.next = list->next;
        list->next = elm;
        elm.next->prev = elm;
    }


    /// Removes an element from the list.
    ///
    /// NOTE: This operation leaves \p elm in an invalid state.
    ///
    /// `elm` Link of the containing struct to remove from the list
    void remove(WlList &elm) {
        elm.prev->next = elm.next;
        elm.next->prev = elm.prev;
        elm.next = null;
        elm.prev = null;
    }


    /// Determines the length of the list.
    ///
    /// NOTE: This is an O(n) operation.
    ///
    /// `return` Number of elements in the list
    u32 size() {
        u32 size = 0;

        for (WlList *e = list.next; e != list; e = e.next) {
            size++;
        }

        return size;
    }


    /// Determines if the list is empty.
    ///
    /// `return` true if empty, or 0 if not empty
    bool is_empty() {
        return list.next == list;
    }


    /// Inserts all of the elements of one list into another, after the element
    /// represented by \p list.
    ///
    /// NOTE: This leaves \p other in an invalid state.
    ///
    /// `other` List of elements to insert
    void insert_list(WlList &other) {
        if (other.is_empty()) {
            return;
        }

        other.next.prev = list;
        other.prev.next = list.next;
        list.next.prev = other.prev;
        list.next = other.next;
    }


    /// Retrieves a pointer to a containing struct, given a member name.
    ///
    /// This macro allows "conversion" from a pointer to a member to its containing
    /// struct. This is useful if you have a contained item like a WlList,
    /// WlListener, or wl_signal, provided via a callback or other means, and would
    /// like to retrieve the struct that contains it.
    ///
    /// To demonstrate, the following example retrieves a pointer to
    /// `ExampleContainer` given only its `destroy_listener` member:
    ///
    /// ```
    /// class ExampleContainer {
    ///     WlListener destroy_listener;
    ///     // other members...
    /// };
    ///
    /// void example_container_destroy(WlListener *listener, void *data) {
    ///     ExampleContainer &ctr = wl_container_of(listener, ctr, destroy_listener);
    ///     // destroy ctr...
    /// }
    /// ```
    ///
    /// NOTE: `sample` need not be a valid pointer. A null or uninitialised pointer
    ///       is sufficient.
    ///
    /// `ptr` Valid pointer to the contained member
    /// `sample` Pointer to a struct whose type contains \p ptr
    /// `member` Named location of \p ptr within the \p sample type
    ///
    /// `return` The container for the specified pointer
    void *wl_container_of<T>(ptr, member) {
        return T((u8 *)(ptr) - offsetof(T *, member));
    }


    /// Iterates over a list.
    ///
    /// This macro expresses a for-each iterator for WlList. Given a list and
    /// WlList link member name (often named `link` by convention), this macro
    /// assigns each element in the list to \p pos, which can then be referenced in
    /// a trailing code block. For example, given a WlList of `struct message`
    /// elements:
    ///
    /// ```
    /// class Message {
    ///     u8 *contents;
    ///     WlList link;
    /// };
    ///
    /// WlList *message_list;
    /// // Assume message_list now "contains" many messages
    ///
    /// Message *m;
    /// message_list.for_each(m, link) {
    ///     do_something_with_message(m);
    /// }
    /// ```
    ///
    /// `pos` Cursor that each list element will be assigned to
    /// `head` Head of the list to iterate over
    /// `member` Name of the link member within the element struct
    void for_each(pos, head, member) {
        for (pos = wl_container_of((head)->next, pos, member);
            &pos->member != (head);
            pos = wl_container_of(pos->member.next, pos, member))
    }


    /// Iterates over a list, safe against removal of the list element.
    ///
    /// NOTE: Only removal of the current element, \p pos, is safe. Removing
    ///       any other element during traversal may lead to a loop malfunction.
    ///
    /// `WlList::for_each()`
    ///
    /// `pos` Cursor that each list element will be assigned to
    /// `tmp` Temporary pointer of the same type as \p pos
    /// `head` Head of the list to iterate over
    /// `member` Name of the link member within the element struct
    void for_each_safe(pos, tmp, head, member) {
        for (pos = wl_container_of(head->next, pos, member),
            tmp = wl_container_of(pos->member.next, tmp, member);
            &pos->member != head;
            pos = tmp,
            tmp = wl_container_of(pos->member.next, tmp, member))
    }


    /// Iterates backwards over a list.
    ///
    /// `WlList::for_each()`
    ///
    /// `pos` Cursor that each list element will be assigned to
    /// `head` Head of the list to iterate over
    /// `member` Name of the link member within the element struct
    void for_each_reverse(pos, head, member)
        for (pos = wl_container_of(head->prev, pos, member);
            &pos->member != head;
            pos = wl_container_of(pos->member.prev, pos, member))


    /// Iterates backwards over a list, safe against removal of the list element.
    ///
    /// NOTE: Only removal of the current element, \p pos, is safe. Removing
    ///       any other element during traversal may lead to a loop malfunction.
    ///
    /// `WlList::for_each()`
    ///
    /// `pos` Cursor that each list element will be assigned to
    /// `tmp` Temporary pointer of the same type as \p pos
    /// `head` Head of the list to iterate over
    /// `member` Name of the link member within the element struct
    void for_each_reverse_safe(pos, tmp, head, member)
        for (pos = wl_container_of(head->prev, pos, member),
            tmp = wl_container_of(pos->member.prev, tmp, member);
            &pos->member != head;
            pos = tmp,
            tmp = wl_container_of(pos->member.prev, tmp, member))
}


/// WlArray
///
/// Dynamic array
///
/// A `WlArray` is a dynamic array that can only grow until released. It is
/// intended for relatively small allocations whose size is variable or not known
/// in advance. While construction of a `WlArray` does not require all elements to
/// be of the same size, `WlArray::for_each()` does require all elements to have
/// the same type and size.
WlArray {
    void *data;
    u32 size;
    u32 alloc;


    /// Initializes the array.
    WlArray() {
        Memory::set(array, 0, size);
    }


    /// Releases the array data.
    ///
    /// NOTE: Leaves the array in an invalid state.
    void release() {
        Memory::free(data);
        data = WL_ARRAY_POISON_PTR;
    }


    /// Increases the size of the array by `size` bytes.
    ///
    /// `size` Number of bytes to increase the size of the array by
    /// `return` A pointer to the beginning of the newly appended space
    /// `fail` when resizing fails.
    void *? add(u32 size) {
        void *p;
        u32 capacity = this.alloc > 0 ? this.alloc : 16;

        while (capacity < this.size + size) {
            capacity *= 2;
        }

        if (this.alloc < capacity) {
            if (this.alloc > 0)
                try Memory::reallocate(data, capacity) {
                    fail;
                }
            else
                try Memory::allocate(data, capacity) {
                    fail;
                }

            this.alloc = alloc;
        }

        p = data + this.size;
        this.size += size;
        return p;
    }


    /// Copies the contents of `source` to `array`.
    ///
    /// `source` Source array to copy from
    /// `fail`
    void? copy(WlArray &source) {
        if (this.size < source.size) {
            try add(array, source.size - this.size) {
                fail;
            }
        } else {
            this.size = source.size;
        }

        if (source.size > 0)
            memcpy(this.data, source.data, source.size);

        return 0;
    }


    /// Iterates over an array.
    ///
    /// This macro expresses a for-each iterator for `WlArray`. It assigns each
    /// element in the array to `pos`, which can then be referenced in a trailing
    /// code block. `pos` must be a pointer to the array element type, and all
    /// array elements must be of the same type and size.
    ///
    /// `pos` Cursor that each array element will be assigned to
    /// `array` Array to iterate over
    ///
    /// `WlList::for_each()`
    void WlArray::for_each(Function<void ()> loop) {
        for (const u8 *pos = data; pos < data + size; pos++) {
            loop();
        }
    }
}


/// Fixed-point number
///
/// A `WlFixed` is a 24.8 signed fixed-point number with a sign bit, 23 bits
/// of integer precision and 8 bits of decimal precision. Consider `WlFixed`
/// as an opaque struct with methods that facilitate conversion to and from
/// `f64` and `i32` types.
type<i32> WlFixed {


    /// Converts a fixed-point number to a floating-point number.
    ///
    /// `return` Floating-point representation of the fixed-point argument
    f64 double() {
        union {
            f64 d;
            u64 i;
        }

        i = ((1023u64 + 44u64) << 52) + (1u64 << 51) + this;
        return d - (3u64 << 43);
    }


    /// Converts a fixed-point number to an integer.
    ///
    /// `return` Integer component of the fixed-point argument
    i32 int() {
        return this / 256;
    }


    /// Converts a floating-point number to a fixed-point number.
    ///
    /// `d` Floating-point number to convert
    /// `return` Fixed-point representation of the floating-point argument
    @shared
    WlFixed from_double(f64 d) {
        union {
            f64 dd;
            i64 i;
        }

        dd = d + (3u64 << (51 - 8));
        return i;
    }


    /// Converts an integer to a fixed-point number.
    ///
    /// `i` Integer to convert
    /// `return` Fixed-point representation of the integer argument
    @shared
    WlFixed from_int(i32 i) {
        return i * 256;
    }
}


/// Protocol message argument data types
///
/// This union represents all of the argument types in the Wayland protocol wire
/// format. The protocol implementation uses `WlArgument` within its marshalling
/// machinery for dispatching messages between a client and a compositor.
///
/// \sa wl_message
/// \sa WlInterface
/// \sa <a href="https://wayland.freedesktop.org/docs/html/ch04.html#sect-Protocol-wire-Format">Wire Format</a>
union WlArgument {
    i32 i;       // `i32`
    u32 u;       // `uint`
    WlFixed f;   // `fixed`
    const u8 *s; // `string`
    WlObject *o; // `object`
    u32 n;       // `new_id`
    WlArray *a;  // `array`
    i32 h;       // `fd`
}


/// Dispatcher function type alias
///
/// A dispatcher is a function that handles the emitting of callbacks in client
/// code. For programs directly using the C library, this is done by using
/// libffi to call function pointers. When binding to languages other than C,
/// dispatchers provide a way to abstract the function calling process to be
/// friendlier to other function calling systems.
///
/// A dispatcher takes five arguments: The first is the dispatcher-specific
/// implementation associated with the target object. The second is the object
/// upon which the callback is being invoked (either wl_proxy or wl_resource).
/// The third and fourth arguments are the opcode and the wl_message
/// corresponding to the callback. The final argument is an array of arguments
/// received from the other process via the wire protocol.
///
/// `user_data` Dispatcher-specific implementation data
/// `target` Callback invocation target (`WlProxy` or `WlResource`)
/// `opcode` Callback opcode
/// `msg` Callback message signature
/// `args` Array of received arguments
/// `fail`
type<void? (const void *user_data, void *target, u32 opcode, const WlMessage *msg, WlArgument *args)*> WlDispatcherFunc;


/// Log function type alias
///
/// The C implementation of the Wayland protocol abstracts the details of
/// logging. Users may customize the logging behavior, with a function conforming
/// to the `WlLogFunc` type, via `WlLog::set_handler_client()` and
/// `WlLog::set_handler_server()`.
///
/// A `WlLogFunc` must conform to the expectations of `vprintf`, and
/// expects two arguments: a string to write and a corresponding variable
/// argument list. While the string to write may contain format specifiers and
/// use values in the variable argument list, the behavior of any `WlLogFunc`
/// depends on the implementation.
///
/// NOTE: Take care to not confuse this with `WlProtocolLoggerFunc`, which
///       is a specific server-side logger for requests and events.
///
/// `fmt` String to write to the log, containing optional format specifiers
/// `args` Variable argument list
///
/// `WlLog::set_handler_client()`
/// `WlLog::set_handler_server()`
type<void (StringView fmt, ... args)*> WlLogFunc;


/// Return value of an iterator function
///
/// `WlClient::for_each_resource_iterator_func_t()`
/// `WlClient::for_each_resource()`
enum<u8> WlIteratorResult {

    // Stop the iteration
    WL_ITERATOR_STOP;

    // Continue the iteration
    WL_ITERATOR_CONTINUE;
}
