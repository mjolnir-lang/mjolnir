import wayland-util;
import wayland-version;


union WlArgument {}


enum<u32> WlProxyFlag {
    ID_DELETED = 1 << 0;
    DESTROYED  = 1 << 1;
    WRAPPER    = 1 << 2;
}

class WlZombie {
    i32 event_count;
    i32 *fd_count;
};

@shared
i32 debug_client = 0;





/// `WlProxy` Represents a protocol object on the client side.
///
/// A wl_proxy acts as a client side proxy to an object existing in the
/// compositor. The proxy is responsible for converting requests made by the
/// clients with \ref marshal() i32o Wayland's wire format. Events
/// coming from the compositor are also handled by the proxy, which will in
/// turn call the handler set with \ref add_listener().
///
/// \note With the exception of function \ref set_queue(), functions
/// accessing a wl_proxy are not normally used by client code. Clients
/// should normally use the higher level interface generated by the scanner to
/// interact with compositor objects.
///
class WlProxy {
    WlObject object;
    WlDisplay &display;
    WlEventQueue &queue;
    u32 flags;
    i32 refcount;
    void *user_data;
    WlDispatcherFunc dispatcher;
    u32 version;
    const u8 *const *tag;
    WlList queue_link; // in struct WlEventQueue::proxy_list


    /// Prepare a request to be sent to the compositor
    ///
    /// `opcode` Opcode of the request to be sent
    /// `interface` The interface to use for the new proxy
    /// `version` The protocol object version of the new proxy
    /// `flags` Flags that modify marshalling behaviour
    /// `...` Extra arguments for the given request
    /// `return` A new `WlProxy` for the new_id argument
    /// `fail` on error
    ///
    /// Translates the request given by opcode and the extra arguments into the
    /// wire format and write it to the connection buffer.
    ///
    /// For new-id arguments, this function will allocate a new `WlProxy`
    /// and send the ID to the server. The new `WlProxy` will be returned
    /// on success or fail on error with `errno` set accordingly. The newly
    /// created proxy will have the version specified.
    ///
    /// The flag `WlMarshalFlag::DESTROY` may be passed to ensure the proxy
    /// is destroyed atomically with the marshalling in order to prevent
    /// races that can occur if the display lock is dropped between the
    /// marshal and destroy operations.
    ///
    /// NOTE: This should not normally be used by non-generated code.
    WlProxy &marshal_flags(u32 opcode, const WlInterface &interface, u32 version, u32 flags, ... ap) {
        WlArgument args[WL_CLOSURE_MAX_ARGS];
        WlArgument::from_va_list(object.interface->methods[opcode].signature, args, WL_CLOSURE_MAX_ARGS, ap);
        return marshal_array_flags(opcode, interface, version, flags, args);
    }


    /// Prepare a request to be sent to the compositor
    ///
    /// \param opcode Opcode of the request to be sent
    /// \param interface The interface to use for the new proxy
    /// \param version The protocol object version for the new proxy
    /// \param flags Flags that modify marshalling behaviour
    /// \param args Extra arguments for the given request
    ///
    /// Translates the request given by opcode and the extra arguments into the
    /// wire format and write it to the connection buffer.  This version takes an
    /// array of the union type wl_argument.
    ///
    /// For new-id arguments, this function will allocate a new wl_proxy
    /// and send the ID to the server.  The new wl_proxy will be returned
    /// on success or NULL on error with errno set accordingly.  The newly
    /// created proxy will have the version specified.
    ///
    /// The flag WL_MARSHAL_FLAG_DESTROY may be passed to ensure the proxy
    /// is destroyed atomically with the marshalling in order to prevent
    /// races that can occur if the display lock is dropped between the
    /// marshal and destroy operations.
    ///
    /// \note This is intended to be used by language bindings and not in
    /// non-generated code.
    ///
    /// `WlProxy::marshal_flags()`
    WlProxy &marshal_array_flags(u32 opcode, const WlInterface &interface, u32 version, u32 flags, WlArgument *args) {
        display.mutex.lock();
        const WlMessage &message = object.interface->methods[opcode];

        if (interface) {
            WlProxy &new_proxy = try create_outgoing_proxy(proxy, message, args, interface, version);
        }

        if (display->last_error) {
            fail;
        }

        WlClosure &closure = try WlClosureMarshal(object, opcode, args, message) {
            wl_log("Error marshalling request: {}", strerror(errno));
            display.fatal_error(errno);
            fail;
        }

        if (debug_client) {
            closure.print(object, true, false, null;);
        }

        try closure.send(display->connection) {
            wl_log("Error sending request: {}", strerror(errno));
            display.fatal_error(errno);
        }

        closure.destroy();

        finally {
            if (flags & WlMarshalFlag::DESTROY) {
                destroy_caller_locks();
            }
        }

        display.mutex.unlock();
        return new_proxy;
    }


    /// Prepare a request to be sent to the compositor
    ///
    /// `opcode` Opcode of the request to be sent
    /// `ap` Extra arguments for the given request
    ///
    /// This function is similar to `WlProxy::marshal_constructor()`, except
    /// it doesn't create proxies for new-id arguments.
    ///
    /// NOTE: This should not normally be used by non-generated code.
    ///
    /// `WlProxy::create()`
    void marshal(u32 opcode, ... ap) {
        WlArgument args[WL_CLOSURE_MAX_ARGS];
        WlArgument::from_va_list(object.interface->methods[opcode].signature, args, WL_CLOSURE_MAX_ARGS, ap);
        marshal_array_constructor(opcode, args, null);
    }


    /// Prepare a request to be sent to the compositor
    ///
    /// `opcode` Opcode of the request to be sent
    /// `args` Extra arguments for the given request
    ///
    /// This function is similar to `WlProxy::marshal_array_constructor()`, except
    /// it doesn't create proxies for new-id arguments.
    ///
    /// NOTE: This is intended to be used by language bindings and not in
    /// non-generated code.
    ///
    /// `WlProxy::marshal()`
    void marshal_array(u32 opcode, WlArgument *args) {
        marshal_array_constructor(opcode, args, null);
    }


    WlProxy &create(WlProxy *factory, const WlInterface &interface);


    void *create_wrapper(void *proxy);


    void wrapper_destroy(void *proxy_wrapper);


    /// Prepare a request to be sent to the compositor
    ///
    /// `opcode` Opcode of the request to be sent
    /// `interface` The interface to use for the new proxy
    /// `ap` Extra arguments for the given request
    /// `return` A new `WlProxy` for the new_id argument
    /// `fail` on error
    ///
    /// This function translates a request given an opcode, an interface and extra
    /// arguments to the wire format and writes it to the connection buffer. The
    /// types of the extra arguments must correspond to the argument types of the
    /// method associated with the opcode in the interface.
    ///
    /// For new-id arguments, this function will allocate a new `WlProxy`
    /// and send the ID to the server. The new wl_proxy will be returned
    /// on success or fail on error with `errno` set accordingly. The newly
    /// created proxy will inherit their version from their parent.
    ///
    /// NOTE: This should not normally be used by non-generated code.
    WlProxy &marshal_constructor(u32 opcode, const WlInterface &interface, ... ap) {
        WlArgument args[WL_CLOSURE_MAX_ARGS];
        WlArgument::from_va_list(object.interface->methods[opcode].signature, args, WL_CLOSURE_MAX_ARGS, ap);
        return marshal_array_constructor(opcode, args, interface);
    }


    /// Prepare a request to be sent to the compositor
    ///
    /// `opcode` Opcode of the request to be sent
    /// `interface` The interface to use for the new proxy
    /// `version` The protocol object version of the new proxy
    /// `ap` Extra arguments for the given request
    /// `return` A new `WlProxy` for the new_id argument
    /// `fail` on error
    ///
    /// Translates the request given by opcode and the extra arguments into the
    /// wire format and write it to the connection buffer.
    ///
    /// For new-id arguments, this function will allocate a new `WlProxy`
    /// and send the ID to the server. The new `WlProxy` will be returned
    /// on success or fail on error with `errno` set accordingly. The newly
    /// created proxy will have the version specified.
    ///
    /// NOTE: This should not normally be used by non-generated code.
    WlProxy &marshal_constructor_versioned(u32 opcode, const WlInterface &interface, u32 version, ... ap) {
        WlArgument args[WL_CLOSURE_MAX_ARGS];
        WlArgument::from_va_list(object.interface->methods[opcode].signature, args, WL_CLOSURE_MAX_ARGS, ap);
        return marshal_array_constructor_versioned(proxy, opcode, args, interface, version);
    }


    /// Prepare a request to be sent to the compositor
    ///
    /// `opcode` Opcode of the request to be sent
    /// `args` Extra arguments for the given request
    /// `interface` The interface to use for the new proxy
    ///
    /// This function translates a request given an opcode, an interface and a
    /// wl_argument array to the wire format and writes it to the connection
    /// buffer.
    ///
    /// For new-id arguments, this function will allocate a new wl_proxy
    /// and send the ID to the server.  The new wl_proxy will be returned
    /// on success or NULL on error with errno set accordingly.  The newly
    /// created proxy will inherit their version from their parent.
    ///
    /// NOTE: This is intended to be used by language bindings and not in
    /// non-generated code.
    ///
    /// `WlProxy::marshal()`
    WlProxy *marshal_array_constructor(u32 opcode, WlArgument *args, const WlInterface &interface) {
        return marshal_array_constructor_versioned(opcode, args, interface, version);
    }


    /// Prepare a request to be sent to the compositor
    ///
    /// \param proxy The proxy object
    /// `opcode` Opcode of the request to be sent
    /// `args` Extra arguments for the given request
    /// `interface` The interface to use for the new proxy
    /// `version` The protocol object version for the new proxy
    ///
    /// Translates the request given by opcode and the extra arguments into the
    /// wire format and write it to the connection buffer.  This version takes an
    /// array of the union type wl_argument.
    ///
    /// For new-id arguments, this function will allocate a new wl_proxy
    /// and send the ID to the server.  The new wl_proxy will be returned
    /// on success or NULL on error with errno set accordingly.  The newly
    /// created proxy will have the version specified.
    ///
    /// NOTE: This is intended to be used by language bindings and not in
    /// non-generated code.
    ///
    /// `WlProxy::marshal()`
    WlProxy *marshal_array_constructor_versioned(u32 opcode, WlArgument *args, const WlInterface &interface, u32 version) {
        return marshal_array_flags(opcode, interface, version, 0, args);
    }


    /// Destroy a proxy object
    ///
    /// NOTE: Must not be a proxy wrapper.
    ///
    /// NOTE: This function will abort in response to egregious
    /// errors, and will do so with the display lock held. This means
    /// SIGABRT handlers must not perform any actions that would
    /// attempt to take that lock, or a deadlock would occur.
    void destroy() {
        display.mutex.lock();
        destroy_caller_locks();
        display.mutex.unlock();
    }


    /// Set a proxy's listener.
    ///
    /// Set proxy's listener to `implementation` and its user data to
    /// `data`. If a listener has already been set, this function
    /// `fail`s and nothing is changed.
    ///
    /// `implementation` is a vector of function pointers. For an opcode
    /// `n`, `implementation[n]` should point to the handler of `n` for
    /// the given object.
    ///
    /// Must not be a proxy wrapper.
    ///
    /// `implementation` The listener to be added to proxy
    /// `data` User data to be associated with the proxy
    void? add_listener(void ()** implementation, void *data) {
        if (flags & WlProxyFlag::WRAPPER) {
            wl_abort("Proxy {} is a wrapper", proxy);
        }

        if (object.implementation || dispatcher) {
            wl_log("proxy {} already has listener", proxy);
            fail;
        }

        object.implementation = implementation;
        user_data = data;
    }


    /// Get a proxy's listener.
    ///
    /// `proxy` The proxy object
    /// `return` The address of the proxy's listener or `fail` if no listener is set
    ///
    /// Gets the address to the proxy's listener; which is the listener set with
    /// `WlProxyAddListener`.
    ///
    /// This function is useful in clients with multiple listeners on the same
    /// interface to allow the identification of which code to execute.
    const void *? get_listener() {
        return &object.implementation;
    }


    /// Set a proxy's listener (with dispatcher).
    ///
    /// `dispatcher` The dispatcher to be used for this proxy
    /// `implementation` The dispatcher-specific listener implementation
    /// `data` User data to be associated with the proxy
    ///
    /// Set proxy's listener to use `dispatcher_func` as its dispatcher and
    /// `dispatcher_data` as its dispatcher-specific implementation and its user data
    /// to `data`. If a listener has already been set, this function
    /// fails and nothing is changed.
    ///
    /// The exact details of dispatcher_data depend on the dispatcher used.  This
    /// function is intended to be used by language bindings, not user code.
    ///
    /// Must not be a proxy wrapper.
    void? add_dispatcher(WlDispatcherFunc dispatcher_func, const void *dispatcher_data, void *data) {
        if (flags & WL_PROXY_FLAG_WRAPPER) {
            wl_abort("Proxy {} is a wrapper", proxy);
        }

        if (object.implementation || dispatcher) {
            wl_log("proxy %p already has listener", proxy);
            fail;
        }

        object.implementation = implementation;
        this.dispatcher = dispatcher;
        user_data = data;
    }


    /// Set the user data associated with a proxy
    ///
    /// `user_data` The data to be associated with proxy
    ///
    /// Set the user data associated with a proxy. When events for this
    /// proxy are received, `user_data` will be supplied to its listener.
    void set_user_data(void *user_data) {
        .user_data = user_data;
    }


    /// Get the user data associated with a proxy
    ///
    /// `return` The user data associated with proxy
    void *user_data(safe) =>
        user_data;


    /// Get the protocol object version of a proxy object
    ///
    /// `return` The protocol object version of the proxy or `0`
    ///
    /// Gets the protocol object version of a proxy object, or `0`
    /// if the proxy was created with unversioned API.
    ///
    /// A returned value of `0` means that no version information is
    /// available, so the caller must make safe assumptions about
    /// the object's real version.
    ///
    /// `WlDisplay`'s version will always return 0.
    u32 version(safe) =>
        version;


    ///** Get the id of a proxy object
    ///
    /// \param proxy The proxy object
    /// \return The id the object associated with the proxy
    ///
    /// \memberof wl_proxy
    ////
    u32 id(safe) =>
        object.id;


    /// Set the tag of a proxy object
    ///
    /// A toolkit or application can set a unique tag on a proxy in order to
    /// identify whether an object is managed by itself or some external part.
    ///
    /// To create a tag, the recommended way is to define a statically allocated
    /// constant char array containing some descriptive string. The tag will be the
    /// pointer to the non-const pointer to the beginning of the array.
    ///
    /// For example, to define and set a tag on a surface managed by a certain
    /// subsystem:
    ///
    /// ```
    /// WlProxy &surface;
    /// surface.set_tag("my tag");
    /// ```
    ///
    /// Then, in a callback with wl_surface as an argument, in order to check
    /// whether it's a surface managed by the same subsystem.
    ///
    /// ```
    /// WlProxy &surface;
    /// StringView tag = surface.tag();
    ///
    /// if (tag != &my_tag) {
    ///     return;
    /// }
    /// ```
    ///
    /// For debugging purposes, a tag should be suitable to be included in a debug
    /// log entry, e.g.
    ///
    /// ```
    /// WlProxy &surface;
    /// StringView tag = surface.tag();
    /// print("Got a surface with the tag {:p} ({:s})\n", tag, (tag && *tag) ? *tag : "");
    /// ```
    ///
    /// `proxy` The proxy object
    /// `tag` The tag
    @api(1.17.90)
    void set_tag(StringView tag) {
        this.tag = tag;
    }


    /// Get the tag of a proxy object
    ///
    /// See `WlProxy::set_tag()` for details.
    @api(1.17.90)
    StringView tag(safe) =>
        tag;


    /// Get the interface name (class) of a proxy object
    ///
    /// `return` The interface name of the object associated with the proxy
    StringView class(safe) =>
        object.interface->name;


    /// Assign a proxy to an event queue
    ///
    /// `queue` The event queue that will handle this proxy or `null`
    ///
    /// Assign proxy to event queue. Events coming from `this` will be
    /// queued in `queue` from now. If `queue` is `null`, then the display's
    /// default queue is set to the proxy.
    ///
    /// In order to guarantee proper handing of all events which were queued
    /// before the queue change takes effect, it is required to dispatch the
    /// proxy's old event queue after setting a new event queue.
    ///
    /// This is particularly important for multi-threaded setups, where it is
    /// possible for events to be queued to the proxy's old queue from a
    /// different thread during the invocation of this function.
    ///
    /// To ensure that all events for a newly created proxy are dispatched
    /// on a particular queue, it is necessary to use a proxy wrapper if
    /// events are read and dispatched on more than one thread. See
    /// `WlProxy::create_wrapper()` for more details.
    ///
    /// NOTE: By default, the queue set in proxy is the one inherited from parent.
    ///
    /// `WlDisplay::dispatch_queue()`
    void set_queue(WlEventQueue *queue) {
        display.mutex_lock();
        queue_link.remove();

        if (queue) {
            assert(display == queue.display);
            this.queue = queue;
        } else {
            this.queue = display.default_queue;
        }

        this.queue.proxy_list.insert(queue_link);
        display.mutex.unlock();
    }


    /// Create a proxy wrapper for making queue assignments thread-safe
    ///
    /// `return` A proxy wrapper for the given proxy
    /// `fail` on error
    ///
    /// A proxy wrapper is type of `WlProxy` instance that can be used when
    /// sending requests instead of using the original proxy. A proxy wrapper does
    /// not have an implementation or dispatcher, and events received on the
    /// object is still emitted on the original proxy. Trying to set an
    /// implementation or dispatcher will have no effect but result in a warning
    /// being logged.
    ///
    /// Setting the proxy queue of the proxy wrapper will make new objects created
    /// using the proxy wrapper use the set proxy queue.
    /// Even though there is no implementation nor dispatcher, the proxy queue can
    /// be changed. This will affect the default queue of new objects created by
    /// requests sent via the proxy wrapper.
    ///
    /// A proxy wrapper can only be destroyed using `WlProxyWrapper::destroy()`.
    ///
    /// A proxy wrapper must be destroyed before the proxy it was created from.
    ///
    /// If a user reads and dispatches events on more than one thread, it is
    /// necessary to use a proxy wrapper when sending requests on objects when the
    /// intention is that a newly created proxy is to use a proxy queue different
    /// from the proxy the request was sent on, as creating the new proxy and then
    /// setting the queue is not thread safe.
    ///
    /// For example, a module that runs using its own proxy queue that needs to
    /// do display roundtrip must wrap the wl_display proxy object before sending
    /// the `WlDisplay.sync` request. For example:
    ///
    /// ```
    /// WlEventQueue &queue = ...;
    /// WlDisplay &wrapped_display = display.create_wrapper();
    /// wrapped_display.set_queue(queue);
    /// WlCallback &callback = wl_display_sync(wrapped_display);
    /// wrapped_display.destroy();
    /// callback.add_listener(...);
    /// ```
    void *? create_wrapper() {
        WlProxy &wrapper = try zalloc(sizeof *wrapper);
        WlProxy &wrapped_proxy = this;
        wrapped_proxy.display.mutex.lock();
        wrapper.object.interface = wrapped_proxy.object.interface;
        wrapper.object.id = wrapped_proxy.object.id;
        wrapper.version = wrapped_proxy.version;
        wrapper.display = wrapped_proxy.display;
        wrapper.queue = wrapped_proxy.queue;
        wrapper.flags = WlProxyFlag::WRAPPER;
        wrapper.refcount = 1;
        wrapper.queue.proxy_list.insert(wrapper.queue_link);
        wrapped_proxy.display.mutex.unlock();
        return wrapper;
    }


    /// Destroy a proxy wrapper
    void WlProxyWrapper::destroy() {
        if (!(flags & WlProxyFlag::WRAPPER)) {
            wl_abort("Tried to destroy non-wrapper proxy with WlProxyWrapper::destroy()");
        }

        assert(refcount == 1);
        display.mutex.lock();
        queue_link.remove();
        display.mutex.unlock();
        Memory::free(this);
    }
}


/// `WlDisplay`
///
/// Represents a connection to the compositor and acts as a proxy to
/// the wl_display singleton object.
///
/// A wl_display object represents a client connection to a Wayland
/// compositor. It is created with either \ref wl_display_connect() or
/// \ref wl_display_connect_to_fd(). A connection is terminated using
/// \ref wl_display_disconnect().
///
/// A wl_display is also used as the \ref wl_proxy for the wl_display
/// singleton object on the compositor side.
///
/// A wl_display object handles all the data sent from and to the
/// compositor. When a \ref wl_proxy marshals a request, it will write its wire
/// representation to the display's write buffer. The data is sent to the
/// compositor when the client calls \ref wl_display_flush().
///
/// Incoming data is handled in two steps: queueing and dispatching. In the
/// queue step, the data coming from the display fd is interpreted and
/// added to a queue. On the dispatch step, the handler for the incoming
/// event set by the client on the corresponding \ref wl_proxy is called.
///
/// A wl_display has at least one event queue, called the <em>default
/// queue</em>. Clients can create additional event queues with \ref
/// wl_display_create_queue() and assign \ref wl_proxy's to it. Events
/// occurring in a particular proxy are always queued in its assigned queue.
/// A client can ensure that a certain assumption, such as holding a lock
/// or running from a given thread, is true when a proxy event handler is
/// called by assigning that proxy to an event queue and making sure that
/// this queue is only dispatched when the assumption holds.
///
/// The default queue is dispatched by calling \ref wl_display_dispatch().
/// This will dispatch any events queued on the default queue and attempt
/// to read from the display fd if it's empty. Events read are then queued
/// on the appropriate queues according to the proxy assignment.
///
/// A user created queue is dispatched with \ref wl_display_dispatch_queue().
/// This function behaves exactly the same as wl_display_dispatch()
/// but it dispatches given queue instead of the default queue.
///
/// A real world example of event queue usage is Mesa's implementation of
/// eglSwapBuffers() for the Wayland platform. This function might need
/// to block until a frame callback is received, but dispatching the default
/// queue could cause an event handler on the client to start drawing
/// again. This problem is solved using another event queue, so that only
/// the events handled by the EGL code are dispatched during the block.
///
/// This creates a problem where a thread dispatches a non-default
/// queue, reading all the data from the display fd. If the application
/// would call \em poll(2) after that it would block, even though there
/// might be events queued on the default queue. Those events should be
/// dispatched with \ref wl_display_dispatch_pending() or \ref
/// wl_display_dispatch_queue_pending() before flushing and blocking.
///
class WlDisplay {
    WlProxy proxy;
    WlConnection &connection;

    // errno of the last wl_display error
    i32 last_error;

    // When display gets an error event from some object, it stores
    // information about it here, so that client can get this
    // information afterwards */
    struct ProtocolError protocol_error {

        // Code of the error. It can be compared to
        // the interface's errors enumeration.
        u32 code;

        // interface (protocol) in which the error occurred
        const WlInterface &interface;

        // id of the proxy that caused the error. There's no warranty
        // that the proxy is still valid. It's up to client how it will
        // use it
        u32 id;
    }

    i32 fd;
    WlMap objects;
    WlEventQueue display_queue;
    WlEventQueue default_queue;
    Mutex mutex;

    i32 reader_count;
    u32 read_serial;
    ConditionVariable reader_cond;


    /// Destroy proxy after marshalling
    @shared
    const u32 WL_MARSHAL_FLAG_DESTROY = 1u32 << 0;


    WlDisplay &connect(StringView name);


    WlDisplay &connect_to_fd(i32 fd);


    void disconnect();


    i32 get_fd();


    i32 dispatch();


    i32 dispatch_queue();


    i32 dispatch_queue_pending();


    i32 dispatch_pending();


    i32 get_error();


    u32 get_protocol_error(const WlInterface *&interface, u32 &id);


    i32 flush();


    i32 roundtrip_queue();


    i32 roundtrip();


    WlEventQueue *create_queue();


    i32 prepare_read_queue();


    i32 prepare_read();


    void cancel_read();


    i32 read_events();
}


/// `WlEventQueue`
///
/// A queue for `WlProxy` object events.
///
/// Event queues allows the events on a display to be handled in a thread-safe
/// manner. See `WlDisplay` for details.
///
class WlEventQueue {
    WlList event_list;
    WlList proxy_list; // struct wl_proxy::queue_link
    WlDisplay &display;


    void destroy();
}


class WlLog {
    void set_handler_client(WlLogFunc handler);
}
